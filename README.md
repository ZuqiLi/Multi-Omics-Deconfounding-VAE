# Multi-omics Deconfounding Variational Autoencoder

![fig3-02](https://github.com/user-attachments/assets/9eba9db0-bd98-4fca-8889-ca44b93121e5)

MODVAE (**M**ulti-**O**mics **D**econfounding **V**ariational **A**uto**E**coder) is a project proposing four novel VAE-based deconfounding frameworks tailored for clustering multi-omics data. These frameworks effectively mitigate confounding effects while preserving genuine biological patterns. The deconfounding strategies employed include (A) a conditional VAE, (B) adversarial training, (C) removal of latent features correlated with confounders, and (D) adding a regularization term to the loss function. For all models, we use a X-shaped architecture to merge the heterogeneous input data sources into a combined latent representation [1]. Consensus clustering is applied to the latent representation generated by each VAE-based model.
Details of this project can be found in our publication [2].

## Environment
For better reproducibility, it's recommended to refer to the following hardware and software settings:
- Operating system: Ubuntu 20.04.6 LTS
- Processor: Intel(R) Xeon(R) Gold 6240R CPU @ 2.40GHz
- Memory: 767 GiB
- Graphics: llvmpipe (LLVM 12.0.0, 256 bits)
- Python version: 3.9.7

The required packages can be installed with the conda environment file in this repository:
```
conda env create -f environment.yml
```

## Tutorial
To use INMTD, please download the `INMTD.py` file in the `Code` folder from this Github repository to your local. 
In `INMTD.py`, there are 3 important functions for users to run INMTD with customization:
&nbsp;
```
init_G(R12, R13, r1, r2, r3, r4, method)
```
### Description:
Initialize embedding matrices $G_1$, $G_2$, $G_3$, and $G_4$.
### Parameters:
- `R12`: The first dataset, a 2D numpy array of size $p1 \times p2$.
- `R13`: The second dataset, a 3D numpy array of size $p1 \times p3 \times p4$.
- `r1`: The rank of $G_1$, a positive integer value.
- `r2`: The rank of $G_2$, a positive integer value.
- `r3`: The rank of $G_3$, a positive integer value.
- `r4`: The rank of $G_4$, a positive integer value.
- `method`: The method used for initialization, a string. Possible values are 'random', 'svd', and 'rsvd'.
  - 'random': Initialize all embedding matrices with random sampling from a uniform distribution of range [0,1].
  - 'svd': Use singluar value decomposition to initialize all embedding matrices. Note that `R13` is decomposed along the last dimension and it singular vectors are averaged over the iterations because it's a 3D array. All singular vectors are ordered descendingly by their corresponding singular values. $G_1$ is then initialized by the average of `r1` left singular vectors of `R12` and `R13`. $G_2$ is initialized by the `r2` right singular vectors of `R12`. $G_3$ is initialized by the `r3` right singular vectors of `R13`. For $G_4$, `R13` is re-decomposed along the first dimension and the average of the `r4` right singular vectors becomes $G_4$. All initialized values <= 0 are replaced by 1e-5.
  - 'rsvd': Use random SVD to decompose `R12` in case of high dimensionality. The rest is the same as 'svd' initialization.
### Returns:
- `G1`: A nonnegative numpy array of size $p1 \times r1$ with `float32` data type.
- `G2`: A nonnegative numpy array of size $p2 \times r2$ with `float32` data type.
- `G3`: A nonnegative numpy array of size $p3 \times r3$ with `float32` data type.
- `G4`: A nonnegative numpy array of size $p4 \times r4$ with `float32` data type.

&nbsp;
```
find_best_r1(R12, R13, r1_list, r2, r3, r4, n_init=10, stop=200)
```
### Description:
Find the best value for `r1`, the rank of $G_1$. This function runs INMTD with random initialization for multiple (`n_init`) times with different `r1` values. In each repitition, a clustering of samples is derived by assigning each sample to the cluster with highest value in the corresponding column of $G_1$. Note that the number of columns of $G_1$, namely `r1`, is the same as number of clusters. Subsequently, a consensus clustering is calculated from the ensemble of clusterings with the same `r1`, yielding a stability score. The `r1` value with highest stability score is chosen as the best.
### Parameters:
- `R12`: The first dataset, a 2D numpy array of size $p1 \times p2$.
- `R13`: The second dataset, a 3D numpy array of size $p1 \times p3 \times p4$.
- `r1_list`: A list of positive integer values for the rank of $G_1$ to be tested.
- `r2`: A positive integer value for the rank of $G_2$.
- `r3`: A positive integer value for the rank of $G_3$.
- `r4`: A positive integer value for the rank of $G_4$.
- `n_init`: A positive integer value for the number of repititions of random initialization. The default is 10.
- `stop`: A positive integer value for the maximal number of iterations that INMTD runs in each repitition. The default is 200.
### Returns:
- A positive integer value for the best `r1`.

&nbsp;
```
INMTD(R12, R13, r1, r2, r3, r4, init='svd', stop=500)
```
### Description:
Run the INMTD model to joint decompose 2D and 3D datasets.
### Parameters:
- `R12`: The first dataset, a 2D numpy array of size $p1 \times p2$.
- `R13`: The second dataset, a 3D numpy array of size $p1 \times p3 \times p4$.
- `r1`: A positive integer value for the rank of $G_1$.
- `r2`: A positive integer value for the rank of $G_2$.
- `r3`: A positive integer value for the rank of $G_3$.
- `r4`: A positive integer value for the rank of $G_4$.
- `init`: A string for the initialization method. Possible values are 'random', 'svd', and 'rsvd'. The default is 'svd'.
- `stop`: A positive integer value for the maximal number of iterations that INMTD runs. The default is 500.
### Returns:
- `embedding`: A list containing embedding matrices $G_1$, $G_2$, $G_3$, $G_4$, the core matrix $S_{12}$ for `R12`, and the core tensor $\mathcal{S}_{13}$ for `R13`.
- `logging`: A 2D numpy array with 6 columns corresponding to the joint reconstruction error of `R12` and `R13`, the reconstruction error of `R12`, the reconstruction error of `R13`, the joint relative error of `R12` and `R13`, the relative error of `R12`, and the relative error of `R13`. Rows are the recording of the 6 metrics in the first 10 iterations and every 10 iterations afterwards.
  
## Example
Here is an example of how to run INMTD with simulated data. Functions and example datasets of the simulation can be found in the `Simulation` folder.
### Simulation
```
from simulation import generate_data


p1, p2, p3, p4 = 1000, 250, 80, 20
r1, r2, r3, r4 = 5, 10, 4, 2

R12, R13, clust1, clust2, clust3, clust4 = generate_data([p1, p2, p3, p4], [r1, r2, r3, r4])
```
The `generate_data` function in `simulation.py` takes 2 parameters as input. The first parameter is a list containing the numbers of dimensions of the 2 datasets to be simulated, namely `R12` and `R13`. The second parameter is another list containing the ranks of the embedding matrices composing `R12` and `R13`. It returns the 2D matrix `R12`, the 3D tensor `R13`, the true clustering on the dimension of `p1`, the true clustering on the dimension of `p2`, the true clustering on the dimension of `p3`, and the true clustering on the dimension of `p4`.

### INMTD pipeline
```
from INMTD import INMTD
import numpy as np


embedding, logging = INMTD(R12, R13, r1, r2, r3, r4)
print(logging)
```

## References
> [1] Simidjievski N, Bodnar C, Tariq I, Scherer P, Andres Terre H, Shams Z, Jamnik M and LiÃ² P (2019) Variational Autoencoders for Cancer Data Integration: Design Principles and Computational Practice. *Frontiers in Genetics*, 10:1205. doi: 10.3389/fgene.2019.01205 \
> [2] Zuqi Li, Sonja Katz, Edoardo Saccenti, David W Fardo, Peter Claes, Vitor A P Martins dos Santos, Kristel Van Steen, Gennady V Roshchupkin, Novel multi-omics deconfounding variational autoencoders can obtain meaningful disease subtyping, *Briefings in Bioinformatics*, Volume 25, Issue 6, November 2024, bbae512, doi: 10.1093/bib/bbae512

 
